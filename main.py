import ccxt
import asyncio
from telegram import Bot, Update, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
    ConversationHandler
)
from telegram.error import TelegramError
import logging
from datetime import datetime, timezone, timedelta
from collections import defaultdict
import html
import re
import json
import os
import time
import aiohttp

# –û–±—â–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
TELEGRAM_TOKEN = "8357883688:AAG5E-IwqpbTn7hJ_320wpvKQpNfkm_QQeo"
TELEGRAM_CHAT_IDS = ["1167694150", "7916502470", "5381553894", "1111230981"]

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–ø–æ—Ç–æ–≤–æ–≥–æ –∞—Ä–±–∏—Ç—Ä–∞–∂–∞ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
DEFAULT_SPOT_SETTINGS = {
    "THRESHOLD_PERCENT": 0.5,
    "MAX_THRESHOLD_PERCENT": 40,
    "CHECK_INTERVAL": 30,
    "MIN_EXCHANGES_FOR_PAIR": 2,
    "MIN_VOLUME_USD": 1000000,
    "MIN_ENTRY_AMOUNT_USDT": 5,
    "MAX_ENTRY_AMOUNT_USDT": 350,
    "MAX_IMPACT_PERCENT": 0.5,
    "ORDER_BOOK_DEPTH": 10,
    "MIN_NET_PROFIT_USD": 4,
    "ENABLED": True,
    "PRICE_CONVERGENCE_THRESHOLD": 0.5,
    "PRICE_CONVERGENCE_ENABLED": True
}

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ DEX –±–∏—Ä–∂
DEX_EXCHANGES = {
    "1inch": {"ENABLED": True},
    "Matcha": {"ENABLED": True},
    "ParaSwap": {"ENABLED": True},
    "Uniswap": {"ENABLED": True},
    "Curve Finance": {"ENABLED": True},
    "Balancer": {"ENABLED": True},
    "SushiSwap": {"ENABLED": True},
    "QuickSwap": {"ENABLED": True},
    "Camelot DEX": {"ENABLED": True},
    "Trader Joe": {"ENABLED": True},
    "Raydium": {"ENABLED": True},
    "Orca": {"ENABLED": True},
    "Jupiter": {"ENABLED": True},
    "STON.fi": {"ENABLED": True},
    "DeDust.io": {"ENABLED": True},
    "Pangolin": {"ENABLED": True},
    "Osmosis": {"ENABLED": True},
    "Maverick Protocol": {"ENABLED": True},
    "THORSwap": {"ENABLED": True}
}

# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è ConversationHandler
SETTINGS_MENU, SPOT_SETTINGS, SETTING_VALUE, COIN_SELECTION = range(4)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger("DEXArbBot")

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –∏ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∞—Ä–±–∏—Ç—Ä–∞–∂–∞
price_convergence_history = defaultdict(dict)
last_convergence_notification = defaultdict(dict)
arbitrage_start_times = defaultdict(dict)
current_arbitrage_opportunities = defaultdict(dict)
previous_arbitrage_opportunities = defaultdict(dict)
sent_arbitrage_opportunities = defaultdict(dict)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫ –±–∏—Ä–∂
LAST_DEX_SETTINGS = None

# DEX Screener API –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
DEX_SCREENER_API = "https://api.dexscreener.com/latest/dex"
DEX_SCREENER_SEARCH_API = "https://api.dexscreener.com/latest/dex/search"

# –ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —Å –∏—Ö –∞–¥—Ä–µ—Å–∞–º–∏
POPULAR_TOKENS = {
    'ETH': '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
    'BTC': '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599',  # WBTC
    'USDC': '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
    'DAI': '0x6b175474e89094c44da98b954eedeac495271d0f',
    'LINK': '0x514910771af9ca656af840dff83e8264ecf986ca',
    'UNI': '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984',
    'AAVE': '0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9',
    'MATIC': '0x7d1afa7b718fb893db30a3abc0cfc608aacfebb0',
    'AVAX': '0x85f138bfee4ef8e540890cfb48f620571d67eda3',
    'SOL': '0xd31a59c85ae9d8edefec411d448f90841571b89c',
    'DOT': '0x43dfc4159d86f3a37a5a4b3d4580b888ad7d4ddd',
    'ADA': '0x3ee2200efb3400fabb9aacf31297cbdd1d435d47',
    'XRP': '0x39fbbabf11738317a448031930706cd3e612e1b9',
    'DOGE': '0x4206931337dc273a630d328da6441786bfad668f',
    'SHIB': '0x95ad61b0a150d79219dcf64e1e6cc01f0b64c4ce',
    'PEPE': '0x6982508145454ce325ddbe47a25d4ec3d2311933',
    'ARB': '0x912ce59144191c1204e64559fe8253a0e49e6548',
    'OP': '0x4200000000000000000000000000000000000042',
    'SUI': '0x2e9d63788249371f1dfc918a52f8d799f4a38c94',
    'APT': '0x1::aptos_coin::AptosCoin'
}

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è DEX –±–∏—Ä–∂ –¥–ª—è DEX Screener
DEX_CONFIGS = {
    "1inch": {
        "api_url": "https://api.1inch.io/v4.0/1/quote",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.003,
        "maker_fee": 0.003,
        "url_format": lambda s: f"https://app.1inch.io/#/1/swap/{s.replace('/', '-')}",
        "emoji": "ü¶Ñ",
        "dex_screener_id": "1inch"
    },
    "Matcha": {
        "api_url": "https://api.matcha.xyz/markets",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.003,
        "maker_fee": 0.003,
        "url_format": lambda s: f"https://matcha.xyz/markets/1/{s.replace('/', '-')}",
        "emoji": "üçµ",
        "dex_screener_id": "matcha"
    },
    "ParaSwap": {
        "api_url": "https://apiv5.paraswap.io/prices",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.003,
        "maker_fee": 0.003,
        "url_format": lambda s: f"https://app.paraswap.io/#/{s.replace('/', '-')}",
        "emoji": "üîÑ",
        "dex_screener_id": "paraswap"
    },
    "Uniswap": {
        "api_url": "https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.003,
        "maker_fee": 0.003,
        "url_format": lambda s: f"https://app.uniswap.org/#/swap?inputCurrency={s.split('/')[0]}&outputCurrency=USDT",
        "emoji": "ü¶Ñ",
        "dex_screener_id": "uniswap"
    },
    "Curve Finance": {
        "api_url": "https://api.curve.fi/api/getPools/ethereum",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.004,
        "maker_fee": 0.004,
        "url_format": lambda s: f"https://curve.fi/#/ethereum/swap",
        "emoji": "üìà",
        "dex_screener_id": "curve"
    },
    "Balancer": {
        "api_url": "https://api.thegraph.com/subgraphs/name/balancer-labs/balancer-v2",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.003,
        "maker_fee": 0.003,
        "url_format": lambda s: f"https://app.balancer.fi/#/trade",
        "emoji": "‚öñÔ∏è",
        "dex_screener_id": "balancer"
    },
    "SushiSwap": {
        "api_url": "https://api.thegraph.com/subgraphs/name/sushiswap/exchange",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.003,
        "maker_fee": 0.003,
        "url_format": lambda s: f"https://app.sushi.com/swap?inputCurrency={s.split('/')[0]}&outputCurrency=USDT",
        "emoji": "üç£",
        "dex_screener_id": "sushiswap"
    },
    "QuickSwap": {
        "api_url": "https://api.thegraph.com/subgraphs/name/sameepsi/quickswap",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.003,
        "maker_fee": 0.003,
        "url_format": lambda
            s: f"https://quickswap.exchange/#/swap?inputCurrency={s.split('/')[0]}&outputCurrency=USDT",
        "emoji": "‚ö°",
        "dex_screener_id": "quickswap"
    },
    "Camelot DEX": {
        "api_url": "https://api.camelot.exchange/swap",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.003,
        "maker_fee": 0.003,
        "url_format": lambda s: f"https://app.camelot.exchange/",
        "emoji": "üê´",
        "dex_screener_id": "camelot"
    },
    "Trader Joe": {
        "api_url": "https://api.traderjoexyz.com/priceusd",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.003,
        "maker_fee": 0.003,
        "url_format": lambda s: f"https://traderjoexyz.com/trade",
        "emoji": "üë®‚Äçüíº",
        "dex_screener_id": "traderjoe"
    },
    "Raydium": {
        "api_url": "https://api.raydium.io/v2/main/price",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.0025,
        "maker_fee": 0.0025,
        "url_format": lambda s: f"https://raydium.io/swap/",
        "emoji": "‚òÄÔ∏è",
        "dex_screener_id": "raydium"
    },
    "Orca": {
        "api_url": "https://api.orca.so/prices",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.003,
        "maker_fee": 0.003,
        "url_format": lambda s: f"https://www.orca.so/swap",
        "emoji": "üêã",
        "dex_screener_id": "orca"
    },
    "Jupiter": {
        "api_url": "https://quote-api.jup.ag/v6/quote",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.003,
        "maker_fee": 0.003,
        "url_format": lambda s: f"https://jup.ag/swap/{s.replace('/', '-')}",
        "emoji": "ü™ê",
        "dex_screener_id": "jupiter"
    },
    "STON.fi": {
        "api_url": "https://api.ston.fi/v1/price",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.003,
        "maker_fee": 0.003,
        "url_format": lambda s: f"https://app.ston.fi/swap",
        "emoji": "üíé",
        "dex_screener_id": "stonfi"
    },
    "DeDust.io": {
        "api_url": "https://api.dedust.io/v1/prices",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.003,
        "maker_fee": 0.003,
        "url_format": lambda s: f"https://dedust.io/swap",
        "emoji": "üí®",
        "dex_screener_id": "dedust"
    },
    "Pangolin": {
        "api_url": "https://api.pangolin.exchange/api/v1/price",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.003,
        "maker_fee": 0.003,
        "url_format": lambda s: f"https://app.pangolin.exchange/swap",
        "emoji": "ü¶é",
        "dex_screener_id": "pangolin"
    },
    "Osmosis": {
        "api_url": "https://api-osmosis.imperator.co/tokens/v2/price",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.003,
        "maker_fee": 0.003,
        "url_format": lambda s: f"https://app.osmosis.zone/swap",
        "emoji": "üî¨",
        "dex_screener_id": "osmosis"
    },
    "Maverick Protocol": {
        "api_url": "https://api.mav.xyz/api/prices",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.003,
        "maker_fee": 0.003,
        "url_format": lambda s: f"https://app.mav.xyz/swap",
        "emoji": "üêé",
        "dex_screener_id": "mav"
    },
    "THORSwap": {
        "api_url": "https://api.thorswap.com/price",
        "symbol_format": lambda s: f"{s}/USDT",
        "taker_fee": 0.003,
        "maker_fee": 0.003,
        "url_format": lambda s: f"https://app.thorswap.finance/swap",
        "emoji": "‚ö°",
        "dex_screener_id": "thorswap"
    }
}


# –ó–∞–≥—Ä—É–∑–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫
def load_settings():
    try:
        if os.path.exists('settings.json'):
            with open('settings.json', 'r') as f:
                return json.load(f)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫: {e}")

    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    return {
        "SPOT": DEFAULT_SPOT_SETTINGS.copy(),
        "DEX": DEX_EXCHANGES.copy()
    }


# –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫
def save_settings(settings):
    try:
        with open('settings.json', 'w') as f:
            json.dump(settings, f, indent=4)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫: {e}")


# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
SHARED_BOT = None
DEX_EXCHANGES_LOADED = {}
SETTINGS = load_settings()


# Reply-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
def get_main_keyboard():
    return ReplyKeyboardMarkup([
        [KeyboardButton("üìà –ê–∫—Ç—É–∞–ª—å–Ω—ã–µ —Å–≤—è–∑–∫–∏")], [KeyboardButton("üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∏")],
        [KeyboardButton("üìä –°—Ç–∞—Ç—É—Å –±–æ—Ç–∞"), KeyboardButton("‚ÑπÔ∏è –ü–æ–º–æ—â—å")]
    ], resize_keyboard=True)


def get_settings_keyboard():
    return ReplyKeyboardMarkup([
        [KeyboardButton("üöÄÔ∏è –°–ø–æ—Ç –ê—Ä–±–∏—Ç—Ä–∞–∂"), KeyboardButton("üèõ DEX –ë–∏—Ä–∂–∏")],
        [KeyboardButton("üîÑ –°–±—Ä–æ—Å"), KeyboardButton("üîô –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é")]
    ], resize_keyboard=True)


def get_spot_settings_keyboard():
    spot = SETTINGS['SPOT']
    return ReplyKeyboardMarkup([
        [KeyboardButton(f"–ü–æ—Ä–æ–≥: {spot['THRESHOLD_PERCENT']}%"),
         KeyboardButton(f"–ú–∞–∫—Å. –ø–æ—Ä–æ–≥: {spot['MAX_THRESHOLD_PERCENT']}%")],
        [KeyboardButton(f"–ò–Ω—Ç–µ—Ä–≤–∞–ª: {spot['CHECK_INTERVAL']}—Å"),
         KeyboardButton(f"–û–±—ä–µ–º: ${spot['MIN_VOLUME_USD'] / 1000:.0f}K")],
        [KeyboardButton(f"–ú–∏–Ω. —Å—É–º–º–∞: ${spot['MIN_ENTRY_AMOUNT_USDT']}"),
         KeyboardButton(f"–ú–∞–∫—Å. —Å—É–º–º–∞: ${spot['MAX_ENTRY_AMOUNT_USDT']}")],
        [KeyboardButton(f"–ü—Ä–∏–±—ã–ª—å: ${spot['MIN_NET_PROFIT_USD']}"),
         KeyboardButton(f"–°—Ç–∞—Ç—É—Å: {'–í–ö–õ' if spot['ENABLED'] else '–í–´–ö–õ'}")],
        [KeyboardButton(f"–°—Ö–æ–¥–∏–º–æ—Å—Ç—å: {spot['PRICE_CONVERGENCE_THRESHOLD']}%"),
         KeyboardButton(f"–£–≤–µ–¥. —Å—Ä–∞–≤–Ω.: {'üîî' if spot['PRICE_CONVERGENCE_ENABLED'] else 'üîï'}")],
        [KeyboardButton("üîô –ù–∞–∑–∞–¥ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏")]
    ], resize_keyboard=True)


def get_dex_settings_keyboard():
    keyboard = []
    row = []
    for i, (exchange, config) in enumerate(SETTINGS['DEX'].items()):
        status = "‚úÖ" if config['ENABLED'] else "‚ùå"
        row.append(KeyboardButton(f"{exchange}: {status}"))
        if (i + 1) % 2 == 0:
            keyboard.append(row)
            row = []
    if row:
        keyboard.append(row)
    keyboard.append([KeyboardButton("üîô –ù–∞–∑–∞–¥ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏")])
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)


async def send_telegram_message(message: str, chat_id: str = None, reply_markup: ReplyKeyboardMarkup = None):
    global SHARED_BOT
    if not SHARED_BOT:
        SHARED_BOT = Bot(token=TELEGRAM_TOKEN)

    targets = [chat_id] if chat_id else TELEGRAM_CHAT_IDS

    for target_id in targets:
        try:
            await SHARED_BOT.send_message(
                chat_id=target_id,
                text=message,
                parse_mode="HTML",
                disable_web_page_preview=True,
                reply_markup=reply_markup
            )
            logger.info(f"–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ —á–∞—Ç {target_id}")
        except TelegramError as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ {target_id}: {e}")


def format_duration(seconds):
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ —á–∏—Ç–∞–µ–º—ã–π –≤–∏–¥"""
    if seconds < 60:
        return f"{int(seconds)} —Å–µ–∫"
    elif seconds < 3600:
        minutes = int(seconds // 60)
        seconds_remaining = int(seconds % 60)
        return f"{minutes} –º–∏–Ω {seconds_remaining} —Å–µ–∫"
    else:
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        return f"{hours} —á {minutes} –º–∏–Ω"


def add_opportunity_to_sent(arb_type: str, base: str, exchange1: str, exchange2: str, spread: float,
                            price1: float, price2: float, volume1: float = None, volume2: float = None,
                            min_entry_amount: float = None, max_entry_amount: float = None,
                            profit_min: dict = None, profit_max: dict = None):
    """–î–æ–±–∞–≤–ª—è–µ—Ç —Å–≤—è–∑–∫—É –≤ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏"""
    key = f"{arb_type}_{base}_{exchange1}_{exchange2}"
    current_time = time.time()

    sent_arbitrage_opportunities[key] = {
        'arb_type': arb_type,
        'base': base,
        'exchange1': exchange1,
        'exchange2': exchange2,
        'spread': spread,
        'price1': price1,
        'price2': price2,
        'volume1': volume1,
        'volume2': volume2,
        'min_entry_amount': min_entry_amount,
        'max_entry_amount': max_entry_amount,
        'profit_min': profit_min,
        'profit_max': profit_max,
        'start_time': current_time,
        'last_updated': current_time
    }

    current_arbitrage_opportunities[key] = sent_arbitrage_opportunities[key].copy()
    arbitrage_start_times[key] = current_time
    previous_arbitrage_opportunities[key] = True

    logger.info(f"–°–≤—è–∑–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ: {key}")


async def send_price_convergence_notification(arb_type: str, base: str, exchange1: str, exchange2: str,
                                              price1: float, price2: float, spread: float, volume1: float = None,
                                              volume2: float = None, duration: float = None):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏ —Ü–µ–Ω —Å –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é –∞—Ä–±–∏—Ç—Ä–∞–∂–∞"""

    if not SETTINGS[arb_type]['PRICE_CONVERGENCE_ENABLED']:
        return

    convergence_threshold = SETTINGS[arb_type]['PRICE_CONVERGENCE_THRESHOLD']

    if abs(spread) > convergence_threshold:
        return

    previous_key = f"{arb_type}_{base}_{exchange1}_{exchange2}"
    if previous_key not in sent_arbitrage_opportunities:
        return

    current_time = time.time()
    notification_key = f"{arb_type}_{base}_{exchange1}_{exchange2}"

    if (notification_key in last_convergence_notification and
            current_time - last_convergence_notification[notification_key] < 300):
        return

    last_convergence_notification[notification_key] = current_time

    utc_plus_3 = timezone(timedelta(hours=3))
    current_time_str = datetime.now(utc_plus_3).strftime('%H:%M:%S')

    def format_volume(vol):
        if vol is None:
            return "N/A"
        if vol >= 1_000_000:
            return f"${vol / 1_000_000:.1f}M"
        if vol >= 1_000:
            return f"${vol / 1_000:.1f}K"
        return f"${vol:.1f}"

    volume1_str = format_volume(volume1)
    volume2_str = format_volume(volume2)
    duration_str = format_duration(duration) if duration is not None else "N/A"

    exchange1_config = DEX_CONFIGS[exchange1]
    exchange2_config = DEX_CONFIGS[exchange2]
    symbol1 = exchange1_config["symbol_format"](base)
    symbol2 = exchange2_config["symbol_format"](base)
    url1 = exchange1_config["url_format"](symbol1)
    url2 = exchange2_config["url_format"](symbol2)

    safe_base = html.escape(base)

    message = (
        f"üéØ <b>–¶–ï–ù–´ –°–†–ê–í–ù–ò–õ–ò–°–¨!</b> üöÄ\n\n"
        f"‚ñ´Ô∏è <b>–¢–∏–ø:</b> DEX –∞—Ä–±–∏—Ç—Ä–∞–∂\n"
        f"‚ñ´Ô∏è <b>–ú–æ–Ω–µ—Ç–∞:</b> <code>{safe_base}</code>\n"
        f"‚ñ´Ô∏è <b>–†–∞–∑–Ω–∏—Ü–∞ —Ü–µ–Ω:</b> <code>{spread:.2f}%</code>\n"
        f"‚ñ´Ô∏è <b>–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∞—Ä–±–∏—Ç—Ä–∞–∂–∞:</b> {duration_str}\n\n"

        f"üü¢ <b><a href='{url1}'>{exchange1.upper()}</a>:</b>\n"
        f"   üí∞ –¶–µ–Ω–∞: <code>${price1:.8f}</code>\n"
        f"   üìä –û–±—ä–µ–º: {volume1_str}\n\n"

        f"üîµ <b><a href='{url2}'>{exchange2.upper()}</a>:</b>\n"
        f"   üí∞ –¶–µ–Ω–∞: <code>${price2:.8f}</code>\n"
        f"   üìä –û–±—ä–µ–º: {volume2_str}\n\n"

        f"‚è∞ <i>{current_time_str}</i>\n"
        f"üîî <i>–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏ —Ü–µ–Ω</i>"
    )

    await send_telegram_message(message)
    logger.info(f"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏ —Ü–µ–Ω –¥–ª—è {base}: {spread:.4f}%, –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {duration_str}")

    key = f"{arb_type}_{base}_{exchange1}_{exchange2}"
    if key in sent_arbitrage_opportunities:
        del sent_arbitrage_opportunities[key]
    if key in current_arbitrage_opportunities:
        del current_arbitrage_opportunities[key]
    if key in arbitrage_start_times:
        del arbitrage_start_times[key]
    if key in previous_arbitrage_opportunities:
        del previous_arbitrage_opportunities[key]

    logger.info(f"–°–≤—è–∑–∫–∞ —É–¥–∞–ª–µ–Ω–∞ –∏–∑ –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö –ø–æ—Å–ª–µ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏ —Ü–µ–Ω: {key}")


def update_arbitrage_duration(arb_type: str, base: str, exchange1: str, exchange2: str, spread: float):
    """–û–±–Ω–æ–≤–ª—è–µ—Ç –≤—Ä–µ–º—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω–æ–π –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏"""
    key = f"{arb_type}_{base}_{exchange1}_{exchange2}"
    current_time = time.time()

    if (key in sent_arbitrage_opportunities and
            SETTINGS[arb_type]['THRESHOLD_PERCENT'] <= spread <= SETTINGS[arb_type]['MAX_THRESHOLD_PERCENT'] and
            key not in arbitrage_start_times):
        arbitrage_start_times[key] = current_time
        previous_arbitrage_opportunities[key] = True
        logger.debug(f"–ù–∞—á–∞–ª–æ –∞—Ä–±–∏—Ç—Ä–∞–∂–∞ –¥–ª—è {key}")

    elif (spread <= SETTINGS[arb_type]['PRICE_CONVERGENCE_THRESHOLD'] and
          key in arbitrage_start_times):
        start_time = arbitrage_start_times.pop(key)
        duration = current_time - start_time
        logger.debug(f"–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∞—Ä–±–∏—Ç—Ä–∞–∂–∞ –¥–ª—è {key}, –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {duration:.0f} —Å–µ–∫")
        return duration

    return None


def update_current_arbitrage_opportunities(arb_type: str, base: str, exchange1: str, exchange2: str, spread: float,
                                           price1: float, price2: float, volume1: float = None, volume2: float = None,
                                           min_entry_amount: float = None, max_entry_amount: float = None,
                                           profit_min: dict = None, profit_max: dict = None):
    """–û–±–Ω–æ–≤–ª—è–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ–∫—É—â–∏—Ö –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è—Ö"""
    key = f"{arb_type}_{base}_{exchange1}_{exchange2}"
    current_time = time.time()

    if key in sent_arbitrage_opportunities:
        current_arbitrage_opportunities[key] = {
            'arb_type': arb_type,
            'base': base,
            'exchange1': exchange1,
            'exchange2': exchange2,
            'spread': spread,
            'price1': price1,
            'price2': price2,
            'volume1': volume1,
            'volume2': volume2,
            'min_entry_amount': min_entry_amount,
            'max_entry_amount': max_entry_amount,
            'profit_min': profit_min,
            'profit_max': profit_max,
            'start_time': sent_arbitrage_opportunities[key]['start_time'],
            'last_updated': current_time
        }


async def get_current_arbitrage_opportunities():
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —Ç–µ–∫—É—â–∏–º–∏ –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã–º–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏"""

    cleanup_old_opportunities()

    filtered_opportunities = {}
    current_time = time.time()

    for key, opportunity in sent_arbitrage_opportunities.items():
        if (current_time - opportunity['last_updated']) <= 3600:
            filtered_opportunities[key] = opportunity

    if not filtered_opportunities:
        return "üìä <b>–ê–∫—Ç—É–∞–ª—å–Ω—ã–µ DEX –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã–µ —Å–≤—è–∑–∫–∏</b>\n\n" \
               "‚è≥ –í –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ."

    spot_opportunities = []

    for key, opportunity in filtered_opportunities.items():
        arb_type = opportunity['arb_type']
        duration = time.time() - opportunity['start_time']

        opportunity_info = {
            'base': opportunity['base'],
            'exchange1': opportunity['exchange1'],
            'exchange2': opportunity['exchange2'],
            'spread': opportunity['spread'],
            'price1': opportunity['price1'],
            'price2': opportunity['price2'],
            'min_entry_amount': opportunity.get('min_entry_amount'),
            'max_entry_amount': opportunity.get('max_entry_amount'),
            'profit_min': opportunity.get('profit_min'),
            'profit_max': opportunity.get('profit_max'),
            'duration': duration
        }

        if arb_type == 'SPOT':
            spot_opportunities.append(opportunity_info)

    spot_opportunities.sort(key=lambda x: x['spread'], reverse=True)

    utc_plus_3 = timezone(timedelta(hours=3))
    current_time_str = datetime.now(utc_plus_3).strftime('%H:%M:%S')

    message = "üìä <b>–ê–∫—Ç—É–∞–ª—å–Ω—ã–µ DEX –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã–µ —Å–≤—è–∑–∫–∏</b>\n\n"

    if spot_opportunities:
        message += "üöÄ <b>DEX –∞—Ä–±–∏—Ç—Ä–∞–∂:</b>\n"
        for opp in spot_opportunities:
            duration_str = format_duration(opp['duration'])

            entry_amount_str = f"${opp['min_entry_amount']:.2f}-${opp['max_entry_amount']:.2f}" if opp.get(
                'min_entry_amount') and opp.get('max_entry_amount') else "N/A"

            profit_str = "N/A"
            if opp.get('profit_min') and opp.get('profit_max'):
                profit_min_net = opp['profit_min'].get('net', 0)
                profit_max_net = opp['profit_max'].get('net', 0)
                profit_str = f"${profit_min_net:.2f}-${profit_max_net:.2f}"

            message += (
                f"   ‚ñ´Ô∏è <code>{opp['base']}</code>: {opp['spread']:.2f}%\n"
                f"      üü¢ {opp['exchange1'].upper()} ‚Üí üî¥ {opp['exchange2'].upper()}\n"
                f"      üí∞ –°—É–º–º–∞ –≤—Ö–æ–¥–∞: {entry_amount_str}\n"
                f"      üíµ –ü—Ä–∏–±—ã–ª—å: {profit_str}\n"
                f"      ‚è± –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {duration_str}\n\n"
            )

    message += f"‚è∞ <i>–û–±–Ω–æ–≤–ª–µ–Ω–æ: {current_time_str}</i>\n"
    message += f"üìà <i>–í—Å–µ–≥–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–≤—è–∑–æ–∫: {len(filtered_opportunities)}</i>"

    return message


def cleanup_old_opportunities():
    """–û—á–∏—â–∞–µ—Ç —É—Å—Ç–∞—Ä–µ–≤—à–∏–µ –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏"""
    current_time = time.time()
    keys_to_remove = []

    for key, opportunity in sent_arbitrage_opportunities.items():
        if current_time - opportunity['last_updated'] > 3600:
            keys_to_remove.append(key)

    for key in keys_to_remove:
        del sent_arbitrage_opportunities[key]
        if key in current_arbitrage_opportunities:
            del current_arbitrage_opportunities[key]
        if key in arbitrage_start_times:
            del arbitrage_start_times[key]
        logger.debug(f"–£–¥–∞–ª–µ–Ω–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∞—è —Å–≤—è–∑–∫–∞: {key}")


async def fetch_dex_screener_data(token_address: str):
    """–ü–æ–ª—É—á–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ —Ç–æ–∫–µ–Ω–µ —Å DEX Screener API"""
    try:
        url = f"{DEX_SCREENER_API}/tokens/{token_address}"
        logger.info(f"–ó–∞–ø—Ä–æ—Å –∫ DEX Screener: {url}")

        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=30) as response:
                if response.status == 200:
                    data = await response.json()
                    logger.info(f"–£—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ç–æ–∫–µ–Ω–∞ {token_address}")
                    return data
                else:
                    logger.warning(f"DEX Screener API error: {response.status} - {await response.text()}")
                    return None
    except asyncio.TimeoutError:
        logger.error(f"–¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ DEX Screener –¥–ª—è —Ç–æ–∫–µ–Ω–∞ {token_address}")
        return None
    except aiohttp.ClientError as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∫–ª–∏–µ–Ω—Ç–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ DEX Screener: {e}")
        return None
    except Exception as e:
        logger.error(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö —Å DEX Screener: {e}")
        return None


async def search_dex_screener(query: str):
    """–ü–æ–∏—Å–∫ —Ç–æ–∫–µ–Ω–æ–≤ –Ω–∞ DEX Screener"""
    try:
        url = f"{DEX_SCREENER_SEARCH_API}?q={query}"
        logger.info(f"–ü–æ–∏—Å–∫ –Ω–∞ DEX Screener: {url}")

        async with aiohttp.ClientSession() as session:
            async with session.get(url, timeout=30) as response:
                if response.status == 200:
                    data = await response.json()
                    logger.info(f"–£—Å–ø–µ—à–Ω—ã–π –ø–æ–∏—Å–∫ –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞: {query}")
                    return data
                else:
                    logger.warning(f"DEX Screener Search API error: {response.status} - {await response.text()}")
                    return None
    except asyncio.TimeoutError:
        logger.error(f"–¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –Ω–∞ DEX Screener –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞: {query}")
        return None
    except aiohttp.ClientError as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∫–ª–∏–µ–Ω—Ç–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –Ω–∞ DEX Screener: {e}")
        return None
    except Exception as e:
        logger.error(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –Ω–∞ DEX Screener: {e}")
        return None


async def get_token_data_from_dex_screener(token_symbol: str):
    """–ü–æ–ª—É—á–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω–∞ —Å DEX Screener"""
    # –°–Ω–∞—á–∞–ª–∞ –ø—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ –ø–æ –∏–∑–≤–µ—Å—Ç–Ω–æ–º—É –∞–¥—Ä–µ—Å—É
    if token_symbol.upper() in POPULAR_TOKENS:
        token_address = POPULAR_TOKENS[token_symbol.upper()]
        logger.info(f"–ü–æ–∏—Å–∫ —Ç–æ–∫–µ–Ω–∞ {token_symbol} –ø–æ –∞–¥—Ä–µ—Å—É: {token_address}")
        data = await fetch_dex_screener_data(token_address)
        if data and 'pairs' in data and data['pairs']:
            logger.info(f"–ù–∞–π–¥–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –¥–ª—è {token_symbol} –ø–æ –∞–¥—Ä–µ—Å—É")
            return data
        else:
            logger.warning(f"–ù–µ –Ω–∞–π–¥–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –¥–ª—è {token_symbol} –ø–æ –∞–¥—Ä–µ—Å—É {token_address}")

    # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –ø–æ –∞–¥—Ä–µ—Å—É, –∏—â–µ–º –ø–æ —Å–∏–º–≤–æ–ª—É
    logger.info(f"–ü–æ–∏—Å–∫ —Ç–æ–∫–µ–Ω–∞ {token_symbol} –ø–æ —Å–∏–º–≤–æ–ª—É")
    search_data = await search_dex_screener(token_symbol)
    if search_data and 'pairs' in search_data and search_data['pairs']:
        logger.info(f"–ù–∞–π–¥–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –¥–ª—è {token_symbol} –ø–æ —Å–∏–º–≤–æ–ª—É")
        return search_data

    logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ç–æ–∫–µ–Ω–∞ {token_symbol}")
    return None


async def fetch_dex_price(dex_name: str, symbol: str):
    """–ü–æ–ª—É—á–∞–µ—Ç —Ü–µ–Ω—É —Å DEX –±–∏—Ä–∂–∏ —á–µ—Ä–µ–∑ DEX Screener"""
    try:
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —Å–∏–º–≤–æ–ª —Ç–æ–∫–µ–Ω–∞ (—É–±–∏—Ä–∞–µ–º /USDT)
        token_symbol = symbol.replace('/USDT', '')

        logger.info(f"–ü–æ–ª—É—á–µ–Ω–∏–µ —Ü–µ–Ω—ã –¥–ª—è {token_symbol} –Ω–∞ {dex_name}")

        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω–∞
        token_data = await get_token_data_from_dex_screener(token_symbol)

        if not token_data or 'pairs' not in token_data or not token_data['pairs']:
            logger.warning(f"–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {symbol} –Ω–∞ DEX Screener")
            return None

        pairs = token_data['pairs']

        # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–∞—Ä—ã –ø–æ DEX –∏ USDT –ø–∞—Ä–µ
        dex_config = DEX_CONFIGS[dex_name]
        dex_screener_id = dex_config.get("dex_screener_id", "").lower()

        relevant_pairs = []
        for pair in pairs:
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ USDT –ø–∞—Ä–∞ –∏ –ø–æ–¥—Ö–æ–¥—è—â–∏–π DEX
                quote_token_symbol = pair.get('quoteToken', {}).get('symbol', '')
                dex_id = pair.get('dexId', '').lower()

                if (quote_token_symbol == 'USDT' and
                        dex_screener_id in dex_id):
                    relevant_pairs.append(pair)
            except Exception as e:
                logger.warning(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–∞—Ä—ã: {e}")
                continue

        if not relevant_pairs:
            logger.debug(f"–ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø–∞—Ä –¥–ª—è {symbol} –Ω–∞ {dex_name}")
            return None

        # –í—ã–±–∏—Ä–∞–µ–º –ø–∞—Ä—É —Å –Ω–∞–∏–±–æ–ª—å—à–∏–º –æ–±—ä–µ–º–æ–º
        best_pair = max(relevant_pairs, key=lambda x: float(x.get('volume', {}).get('h24', 0)))

        price_str = best_pair.get('priceUsd')
        if not price_str:
            logger.warning(f"–ù–µ—Ç —Ü–µ–Ω—ã –¥–ª—è –ø–∞—Ä—ã {symbol} –Ω–∞ {dex_name}")
            return None

        price = float(price_str)
        volume_24h = float(best_pair.get('volume', {}).get('h24', 0))
        liquidity = float(best_pair.get('liquidity', {}).get('usd', 0))

        if price <= 0:
            logger.warning(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Ü–µ–Ω–∞ –¥–ª—è {symbol} –Ω–∞ {dex_name}: {price}")
            return None

        logger.info(f"–£—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω–∞ —Ü–µ–Ω–∞ {price} –¥–ª—è {symbol} –Ω–∞ {dex_name}")

        return {
            'price': price,
            'volume': volume_24h,
            'liquidity': liquidity,
            'symbol': symbol,
            'pair_address': best_pair.get('pairAddress'),
            'dex_id': best_pair.get('dexId')
        }

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω—ã {symbol} –Ω–∞ {dex_name}: {e}")
        return None


def calculate_min_entry_amount(buy_price: float, sell_price: float, min_profit: float, buy_fee_percent: float,
                               sell_fee_percent: float) -> float:
    profit_per_unit = sell_price * (1 - sell_fee_percent) - buy_price * (1 + buy_fee_percent)
    if profit_per_unit <= 0:
        return 0
    min_amount = min_profit / profit_per_unit
    return min_amount * buy_price


def calculate_profit(buy_price: float, sell_price: float, amount: float, buy_fee_percent: float,
                     sell_fee_percent: float) -> dict:
    buy_cost = amount * buy_price * (1 + buy_fee_percent)
    sell_revenue = amount * sell_price * (1 - sell_fee_percent)
    net_profit = sell_revenue - buy_cost
    profit_percent = (net_profit / buy_cost) * 100 if buy_cost > 0 else 0

    return {
        "net": net_profit,
        "percent": profit_percent,
        "entry_amount": amount * buy_price
    }


async def load_dex_exchanges():
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç DEX –±–∏—Ä–∂–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–∫—É—â–∏—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫"""
    global DEX_EXCHANGES_LOADED, LAST_DEX_SETTINGS

    exchanges = {}
    for name in DEX_CONFIGS.keys():
        if not SETTINGS['DEX'][name]['ENABLED']:
            continue

        try:
            exchanges[name] = {"config": DEX_CONFIGS[name]}
            logger.info(f"{name.upper()} —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–∞")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ {name}: {e}")

    DEX_EXCHANGES_LOADED = exchanges
    LAST_DEX_SETTINGS = SETTINGS['DEX'].copy()
    return exchanges


async def check_spot_arbitrage():
    logger.info("–ó–∞–ø—É—Å–∫ –ø—Ä–æ–≤–µ—Ä–∫–∏ DEX –∞—Ä–±–∏—Ç—Ä–∞–∂–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º DEX Screener")

    if not SETTINGS['SPOT']['ENABLED']:
        logger.info("DEX –∞—Ä–±–∏—Ç—Ä–∞–∂ –æ—Ç–∫–ª—é—á–µ–Ω –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö")
        return

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∏—Ä–∂
    await load_dex_exchanges()

    if len(DEX_EXCHANGES_LOADED) < SETTINGS['SPOT']['MIN_EXCHANGES_FOR_PAIR']:
        logger.error(f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ DEX –±–∏—Ä–∂ (–Ω—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º {SETTINGS['SPOT']['MIN_EXCHANGES_FOR_PAIR']})")
        return

    # –°–ø–∏—Å–æ–∫ –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
    popular_tokens = list(POPULAR_TOKENS.keys())

    logger.info(f"–ù–∞—á–∏–Ω–∞–µ–º –∞–Ω–∞–ª–∏–∑ {len(popular_tokens)} –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤ —á–µ—Ä–µ–∑ DEX Screener")

    while SETTINGS['SPOT']['ENABLED']:
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏–∑–º–µ–Ω–∏–ª–∏—Å—å –ª–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –±–∏—Ä–∂
            if LAST_DEX_SETTINGS != SETTINGS['DEX']:
                logger.info("–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –∏–∑–º–µ–Ω–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫ DEX –±–∏—Ä–∂. –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º...")
                await load_dex_exchanges()

                if len(DEX_EXCHANGES_LOADED) < SETTINGS['SPOT']['MIN_EXCHANGES_FOR_PAIR']:
                    logger.error("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ DEX –±–∏—Ä–∂ –ø–æ—Å–ª–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∏")
                    await asyncio.sleep(SETTINGS['SPOT']['CHECK_INTERVAL'])
                    continue

            found_opportunities = 0
            for base in popular_tokens:
                try:
                    ticker_data = {}

                    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Ç–∏–∫–µ—Ä–æ–≤ –¥–ª—è –≤—Å–µ—Ö DEX –±–∏—Ä–∂ —á–µ—Ä–µ–∑ DEX Screener
                    for name, data in DEX_EXCHANGES_LOADED.items():
                        try:
                            symbol = data["config"]["symbol_format"](base)
                            data_result = await fetch_dex_price(name, symbol)
                            if data_result and data_result['price'] is not None:
                                if data_result['volume'] is None or data_result['volume'] >= SETTINGS['SPOT'][
                                    'MIN_VOLUME_USD']:
                                    ticker_data[name] = data_result
                                else:
                                    logger.debug(f"–û–±—ä–µ–º {symbol} –Ω–∞ {name} —Å–ª–∏—à–∫–æ–º –º–∞–ª: {data_result['volume']}")
                            else:
                                logger.debug(f"–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {symbol} –Ω–∞ {name}")
                        except Exception as e:
                            logger.warning(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö {base} –Ω–∞ {name}: {e}")

                    if len(ticker_data) < SETTINGS['SPOT']['MIN_EXCHANGES_FOR_PAIR']:
                        continue

                    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –±–∏—Ä–∂–∏ –ø–æ —Ü–µ–Ω–µ
                    sorted_data = sorted(ticker_data.items(), key=lambda x: x[1]['price'])
                    min_ex = sorted_data[0]  # –°–∞–º–∞—è –Ω–∏–∑–∫–∞—è —Ü–µ–Ω–∞ (–ø–æ–∫—É–ø–∫–∞)
                    max_ex = sorted_data[-1]  # –°–∞–º–∞—è –≤—ã—Å–æ–∫–∞—è —Ü–µ–Ω–∞ (–ø—Ä–æ–¥–∞–∂–∞)

                    # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–ø—Ä–µ–¥
                    spread = (max_ex[1]['price'] - min_ex[1]['price']) / min_ex[1]['price'] * 100

                    logger.info(
                        f"–¢–æ–∫–µ–Ω {base}: —Å–ø—Ä–µ–¥ {spread:.2f}% (min: {min_ex[0]} {min_ex[1]['price']}, max: {max_ex[0]} {max_ex[1]['price']})")

                    # –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ–∫—É—â–∏—Ö –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è—Ö
                    update_current_arbitrage_opportunities(
                        'SPOT', base, min_ex[0], max_ex[0], spread,
                        min_ex[1]['price'], max_ex[1]['price'],
                        min_ex[1]['volume'], max_ex[1]['volume']
                    )

                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ö–æ–¥–∏–º–æ—Å—Ç—å —Ü–µ–Ω –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
                    duration = update_arbitrage_duration('SPOT', base, min_ex[0], max_ex[0], spread)
                    if duration is not None:
                        await send_price_convergence_notification(
                            'SPOT', base, min_ex[0], max_ex[0],
                            min_ex[1]['price'], max_ex[1]['price'], spread,
                            min_ex[1]['volume'], max_ex[1]['volume'], duration
                        )

                    if SETTINGS['SPOT']['THRESHOLD_PERCENT'] <= spread <= SETTINGS['SPOT']['MAX_THRESHOLD_PERCENT']:
                        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–∏—Å—Å–∏–∏
                        buy_fee = DEX_EXCHANGES_LOADED[min_ex[0]]["config"]["taker_fee"]
                        sell_fee = DEX_EXCHANGES_LOADED[max_ex[0]]["config"]["taker_fee"]

                        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é —Å—É–º–º—É –¥–ª—è MIN_NET_PROFIT_USD
                        min_amount_for_profit = calculate_min_entry_amount(
                            buy_price=min_ex[1]['price'],
                            sell_price=max_ex[1]['price'],
                            min_profit=SETTINGS['SPOT']['MIN_NET_PROFIT_USD'],
                            buy_fee_percent=buy_fee,
                            sell_fee_percent=sell_fee
                        )

                        if min_amount_for_profit <= 0:
                            logger.debug(f"–ü—Ä–æ–ø—É—Å–∫–∞–µ–º {base}: –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–∞—è –ø—Ä–∏–±—ã–ª—å")
                            continue

                        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≤–æ–∑–º–æ–∂–Ω—É—é —Å—É–º–º—É –≤—Ö–æ–¥–∞
                        max_entry_amount = SETTINGS['SPOT']['MAX_ENTRY_AMOUNT_USDT']
                        min_entry_amount = max(min_amount_for_profit, SETTINGS['SPOT']['MIN_ENTRY_AMOUNT_USDT'])

                        if min_entry_amount > max_entry_amount:
                            logger.debug(f"–ü—Ä–æ–ø—É—Å–∫–∞–µ–º {base}: min_entry_amount > max_entry_amount")
                            continue

                        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø—Ä–∏–±—ã–ª—å
                        profit_min = calculate_profit(
                            buy_price=min_ex[1]['price'],
                            sell_price=max_ex[1]['price'],
                            amount=min_entry_amount / min_ex[1]['price'],
                            buy_fee_percent=buy_fee,
                            sell_fee_percent=sell_fee
                        )

                        profit_max = calculate_profit(
                            buy_price=min_ex[1]['price'],
                            sell_price=max_ex[1]['price'],
                            amount=max_entry_amount / min_ex[1]['price'],
                            buy_fee_percent=buy_fee,
                            sell_fee_percent=sell_fee
                        )

                        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
                        utc_plus_3 = timezone(timedelta(hours=3))
                        current_time = datetime.now(utc_plus_3).strftime('%H:%M:%S')

                        def format_volume(vol):
                            if vol is None:
                                return "N/A"
                            if vol >= 1_000_000:
                                return f"${vol / 1_000_000:.1f}M"
                            if vol >= 1_000:
                                return f"${vol / 1_000:.1f}K"
                            return f"${vol:.1f}"

                        min_volume = format_volume(min_ex[1]['volume'])
                        max_volume = format_volume(max_ex[1]['volume'])

                        safe_base = html.escape(base)
                        buy_exchange_config = DEX_CONFIGS[min_ex[0]]
                        sell_exchange_config = DEX_CONFIGS[max_ex[0]]

                        # –ü–æ–ª—É—á–∞–µ–º –ø—Ä—è–º—ã–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ –ø–∞—Ä—ã –∏–∑ DEX Screener
                        buy_url = f"https://dexscreener.com/{min_ex[1].get('dex_id', 'ethereum')}/{min_ex[1].get('pair_address', '')}"
                        sell_url = f"https://dexscreener.com/{max_ex[1].get('dex_id', 'ethereum')}/{max_ex[1].get('pair_address', '')}"

                        message = (
                            f"üöÄ <b>DEX –ê—Ä–±–∏—Ç—Ä–∞–∂ (Real-time):</b> <code>{safe_base}</code>\n"
                            f"‚ñ´Ô∏è <b>–†–∞–∑–Ω–∏—Ü–∞ —Ü–µ–Ω:</b> {spread:.2f}%\n"
                            f"‚ñ´Ô∏è <b>–°—É–º–º–∞ –≤—Ö–æ–¥–∞:</b> ${min_entry_amount:.2f}-${max_entry_amount:.2f}\n\n"
                            f"üü¢ <b>–ü–æ–∫—É–ø–∫–∞ –Ω–∞ <a href='{buy_url}'>{min_ex[0].upper()}</a>:</b> ${min_ex[1]['price']:.8f}\n"
                            f"   <b>–û–±—ä—ë–º 24h:</b> {min_volume}\n"
                            f"   <b>–ö–æ–º–∏—Å—Å–∏—è:</b> {buy_fee * 100:.2f}%\n\n"
                            f"üî¥ <b>–ü—Ä–æ–¥–∞–∂–∞ –Ω–∞ <a href='{sell_url}'>{max_ex[0].upper()}</a>:</b> ${max_ex[1]['price']:.8f}\n"
                            f"   <b>–û–±—ä—ë–º 24h:</b> {max_volume}\n"
                            f"   <b>–ö–æ–º–∏—Å—Å–∏—è:</b> {sell_fee * 100:.2f}%\n\n"
                            f"üí∞ <b>–ß–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å:</b> ${profit_min['net']:.2f}-${profit_max['net']:.2f} ({profit_max['percent']:.2f}%)\n\n"
                            f"‚è± {current_time}\n"
                            f"üì° <i>–î–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ DEX Screener</i>"
                        )

                        logger.info(f"–ù–∞–π–¥–µ–Ω–∞ DEX –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω–∞—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å: {base} ({spread:.2f}%)")

                        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ Telegram
                        await send_telegram_message(message)

                        # –î–æ–±–∞–≤–ª—è–µ–º —Å–≤—è–∑–∫—É –≤ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏
                        add_opportunity_to_sent(
                            'SPOT', base, min_ex[0], max_ex[0], spread,
                            min_ex[1]['price'], max_ex[1]['price'],
                            min_ex[1]['volume'], max_ex[1]['volume'],
                            min_entry_amount, max_entry_amount, profit_min, profit_max
                        )

                        found_opportunities += 1

                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ç–æ–∫–µ–Ω–∞ {base}: {e}")

            # –û—á–∏—â–∞–µ–º —É—Å—Ç–∞—Ä–µ–≤—à–∏–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏
            cleanup_old_opportunities()

            logger.info(f"–¶–∏–∫–ª DEX –∞—Ä–±–∏—Ç—Ä–∞–∂–∞ –∑–∞–≤–µ—Ä—à–µ–Ω. –ù–∞–π–¥–µ–Ω–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π: {found_opportunities}")
            await asyncio.sleep(SETTINGS['SPOT']['CHECK_INTERVAL'])

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º —Ü–∏–∫–ª–µ DEX –∞—Ä–±–∏—Ç—Ä–∞–∂–∞: {e}")
            await asyncio.sleep(60)


def format_price(price: float) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ü–µ–Ω—É –¥–ª—è –∫—Ä–∞—Å–∏–≤–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
    if price is None:
        return "N/A"

    if price >= 1000:
        return f"$<code>{price:.2f}</code>"

    if price >= 1:
        return f"$<code>{price:.4f}</code>"

    return f"$<code>{price:.8f}</code>"


def format_volume(vol: float) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –æ–±—ä–µ–º –¥–ª—è –∫—Ä–∞—Å–∏–≤–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
    if vol is None:
        return "N/A"

    if vol >= 1_000_000:
        return f"${vol / 1_000_000:.1f}M"

    if vol >= 1_000:
        return f"${vol / 1_000:.1f}K"

    return f"${vol:.0f}"


async def get_coin_prices(coin: str):
    """–ü–æ–ª—É—á–∞–µ—Ç —Ü–µ–Ω—ã –º–æ–Ω–µ—Ç—ã –Ω–∞ –≤—Å–µ—Ö DEX –±–∏—Ä–∂–∞—Ö —á–µ—Ä–µ–∑ DEX Screener"""
    coin = coin.upper()

    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω–∞ —Å DEX Screener
    token_data = await get_token_data_from_dex_screener(coin)

    if not token_data or 'pairs' not in token_data or not token_data['pairs']:
        return f"‚ùå –ú–æ–Ω–µ—Ç–∞ {coin} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∞ DEX Screener –∏–ª–∏ –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ –ø–∞—Ä–∞—Ö"

    pairs = token_data['pairs']

    # –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ USDT –ø–∞—Ä—ã —Å –¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–º –æ–±—ä–µ–º–æ–º
    min_volume = SETTINGS['SPOT']['MIN_VOLUME_USD']
    usdt_pairs = [
        pair for pair in pairs
        if pair.get('quoteToken', {}).get('symbol') == 'USDT'
           and float(pair.get('volume', {}).get('h24', 0)) >= min_volume
    ]

    if not usdt_pairs:
        return f"‚ùå –ú–æ–Ω–µ—Ç–∞ {coin} –Ω–µ –∏–º–µ–µ—Ç USDT –ø–∞—Ä —Å –æ–±—ä–µ–º–æ–º > ${min_volume:,.0f}"

    # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Ü–µ–Ω–µ
    usdt_pairs.sort(key=lambda x: float(x.get('priceUsd', 0)))

    results = []
    for pair in usdt_pairs:
        dex_name = pair.get('dexId', 'Unknown').title()
        price_str = pair.get('priceUsd')
        if not price_str:
            continue

        price = float(price_str)
        volume_24h = float(pair.get('volume', {}).get('h24', 0))
        liquidity = float(pair.get('liquidity', {}).get('usd', 0))

        pair_address = pair.get('pairAddress')
        url = f"https://dexscreener.com/{pair.get('chainId', 'ethereum')}/{pair_address}"

        # –ù–∞—Ö–æ–¥–∏–º —ç–º–æ–¥–∑–∏ –¥–ª—è DEX
        emoji = "ü¶Ñ"  # –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        for config_name, config in DEX_CONFIGS.items():
            if config.get("dex_screener_id", "").lower() in dex_name.lower():
                emoji = config.get("emoji", "ü¶Ñ")
                dex_name = config_name  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—à–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ
                break

        results.append({
            "price": price,
            "name": dex_name.upper(),
            "volume": volume_24h,
            "liquidity": liquidity,
            "url": url,
            "emoji": emoji,
            "pair_address": pair_address
        })

    results.sort(key=lambda x: x["price"])

    utc_plus_3 = timezone(timedelta(hours=3))
    current_time = datetime.now(utc_plus_3).strftime('%H:%M:%S')

    if results:
        min_price = results[0]["price"]
        max_price = results[-1]["price"]
        price_diff_percent = ((max_price - min_price) / min_price) * 100

        response = f"ü¶Ñ <b>DEX —Ä—ã–Ω–∫–∏ –¥–ª—è <code>{coin}</code> (Real-time):</b>\n\n"
        response += f"<i>–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –æ–±—ä–µ–º: ${min_volume:,.0f}</i>\n"
        response += f"<i>–ù–∞–π–¥–µ–Ω–æ DEX: {len(results)}</i>\n\n"

        for idx, item in enumerate(results, 1):
            response += (
                f"{item['emoji']} <a href='{item['url']}'><b>{item['name']}</b></a>\n"
                f"‚ñ´Ô∏è –¶–µ–Ω–∞: {format_price(item['price'])}\n"
                f"‚ñ´Ô∏è –û–±—ä–µ–º 24h: {format_volume(item['volume'])}\n"
                f"‚ñ´Ô∏è –õ–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å: {format_volume(item['liquidity'])}\n"
            )

            if idx < len(results):
                response += "\n"

        if len(results) >= 2 and min_price < max_price:
            min_exchange = results[0]
            max_exchange = results[-1]

            # –ü–æ–ª—É—á–∞–µ–º –∫–æ–º–∏—Å—Å–∏–∏ –¥–ª—è DEX
            buy_fee = 0.003  # –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            sell_fee = 0.003  # –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

            for config_name, config in DEX_CONFIGS.items():
                if config_name.lower() == min_exchange['name'].lower():
                    buy_fee = config["taker_fee"]
                if config_name.lower() == max_exchange['name'].lower():
                    sell_fee = config["taker_fee"]

            min_entry = SETTINGS['SPOT']['MIN_ENTRY_AMOUNT_USDT']
            max_entry = SETTINGS['SPOT']['MAX_ENTRY_AMOUNT_USDT']

            profit_min = calculate_profit(
                buy_price=min_price,
                sell_price=max_price,
                amount=min_entry / min_price,
                buy_fee_percent=buy_fee,
                sell_fee_percent=sell_fee
            )

            profit_max = calculate_profit(
                buy_price=min_price,
                sell_price=max_price,
                amount=max_entry / min_price,
                buy_fee_percent=buy_fee,
                sell_fee_percent=sell_fee
            )

            response += f"\nüíº <b>–í–æ–∑–º–æ–∂–Ω—ã–π –∞—Ä–±–∏—Ç—Ä–∞–∂:</b>\n"
            response += f"üü¢ –ü–æ–∫—É–ø–∫–∞ –Ω–∞ {min_exchange['name']}: {format_price(min_price)}\n"
            response += f"üî¥ –ü—Ä–æ–¥–∞–∂–∞ –Ω–∞ {max_exchange['name']}: {format_price(max_price)}\n"
            response += f"üí∞ –°—É–º–º–∞ –≤—Ö–æ–¥–∞: ${min_entry:.2f}-${max_entry:.2f}\n"
            response += f"üíµ –ß–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å: ${profit_min['net']:.2f}-${profit_max['net']:.2f}\n"

        response += f"\nüìà <b>–†–∞–∑–Ω–∏—Ü–∞ —Ü–µ–Ω:</b> {price_diff_percent:.2f}%\n"
        response += f"‚è± {current_time} | DEX: {len(results)}"
        response += f"\nüì° <i>–î–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ DEX Screener</i>"
    else:
        response = f"‚ùå –ú–æ–Ω–µ—Ç–∞ {coin} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∞ DEX —Ä—ã–Ω–∫–∞—Ö —Å –¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–º –æ–±—ä–µ–º–æ–º"

    return response


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
    user_id = str(update.effective_user.id)
    if user_id not in TELEGRAM_CHAT_IDS:
        await update.message.reply_text("‚õî –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.")
        return

    await update.message.reply_text(
        "ü§ñ <b>DEX Arbitrage Bot v2.0</b>\n\n"
        "–ë–æ—Ç –¥–ª—è –ø–æ–∏—Å–∫–∞ –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π –Ω–∞ –¥–µ—Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã—Ö –±–∏—Ä–∂–∞—Ö\n"
        "üì° <i>–¢–µ–ø–µ—Ä—å —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ —á–µ—Ä–µ–∑ DEX Screener API</i>\n\n"
        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –±–æ—Ç–æ–º:",
        parse_mode="HTML",
        reply_markup=get_main_keyboard()
    )


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
    user_id = str(update.effective_user.id)
    if user_id not in TELEGRAM_CHAT_IDS:
        await update.message.reply_text("‚õî –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.")
        return

    text = update.message.text

    if text == "üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∏":
        await update.message.reply_text(
            "‚öôÔ∏è <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ DEX –±–æ—Ç–∞ v2.0</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:",
            parse_mode="HTML",
            reply_markup=get_settings_keyboard()
        )
        return SETTINGS_MENU

    elif text == "üìà –ê–∫—Ç—É–∞–ª—å–Ω—ã–µ —Å–≤—è–∑–∫–∏":
        await update.message.reply_text(
            "‚è≥ –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ–∫—É—â–∏—Ö DEX –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è—Ö...",
            parse_mode="HTML"
        )

        response = await get_current_arbitrage_opportunities()

        await update.message.reply_text(
            text=response,
            parse_mode="HTML",
            disable_web_page_preview=True,
            reply_markup=get_main_keyboard()
        )
        return

    elif text == "üìä –°—Ç–∞—Ç—É—Å –±–æ—Ç–∞":
        spot_status = "‚úÖ –í–ö–õ" if SETTINGS['SPOT']['ENABLED'] else "‚ùå –í–´–ö–õ"

        enabled_dex = [name for name, config in SETTINGS['DEX'].items() if config['ENABLED']]
        dex_status = ", ".join(enabled_dex) if enabled_dex else "–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö DEX"

        await update.message.reply_text(
            f"ü§ñ <b>–°—Ç–∞—Ç—É—Å DEX –±–æ—Ç–∞ v2.0</b>\n\n"
            f"üöÄ DEX –∞—Ä–±–∏—Ç—Ä–∞–∂: {spot_status}\n"
            f"ü¶Ñ –ê–∫—Ç–∏–≤–Ω—ã–µ DEX: {dex_status}\n"
            f"üìà –ê–∫—Ç–∏–≤–Ω—ã—Ö —Å–≤—è–∑–æ–∫: {len(sent_arbitrage_opportunities)}\n"
            f"üì° –ò—Å—Ç–æ—á–Ω–∏–∫ –¥–∞–Ω–Ω—ã—Ö: DEX Screener API",
            parse_mode="HTML",
            reply_markup=get_main_keyboard()
        )
        return

    elif text == "‚ÑπÔ∏è –ü–æ–º–æ—â—å":
        await update.message.reply_text(
            "ü§ñ <b>DEX Arbitrage Bot v2.0</b>\n\n"
            "üîç <b>–ü–æ–∏—Å–∫ –º–æ–Ω–µ—Ç—ã</b> - –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Ä–µ–∞–ª—å–Ω—ã–µ —Ü–µ–Ω—ã –Ω–∞ —Ä–∞–∑–Ω—ã—Ö DEX —á–µ—Ä–µ–∑ DEX Screener, –ø—Ä–æ—Å—Ç–æ –≤–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–æ–Ω–µ—Ç—ã (ETH, BTC, USDC...)\n"
            "üîß <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</b> - –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∞—Ä–±–∏—Ç—Ä–∞–∂–∞ –∏ DEX –±–∏—Ä–∂–∏\n"
            "üìä <b>–°—Ç–∞—Ç—É—Å –±–æ—Ç–∞</b> - –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±–æ—Ç–∞\n"
            "üìà <b>–ê–∫—Ç—É–∞–ª—å–Ω—ã–µ —Å–≤—è–∑–∫–∏</b> - –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Ç–µ–∫—É—â–∏–µ –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏\n\n"
            "ü¶Ñ <b>–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ DEX:</b>\n"
            "1inch, Matcha, ParaSwap, Uniswap, Curve, Balancer, SushiSwap, QuickSwap,\n"
            "Camelot, Trader Joe, Raydium, Orca, Jupiter, STON.fi, DeDust, Pangolin,\n"
            "Osmosis, Maverick, THORSwap\n\n"
            "üì° <b>–ò—Å—Ç–æ—á–Ω–∏–∫ –¥–∞–Ω–Ω—ã—Ö:</b> DEX Screener API (—Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ)",
            parse_mode="HTML",
            reply_markup=get_main_keyboard()
        )
        return

    # –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ –∫–æ–º–∞–Ω–¥–∞, –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ —ç—Ç–æ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–æ–Ω–µ—Ç—ã
    if not text.startswith('/'):
        if re.match(r'^[A-Z0-9]{1,15}$', text.upper()):
            context.user_data['coin'] = text.upper()

            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º "–ó–∞–≥—Ä—É–∑–∫–∞..."
            await update.message.reply_text(
                f"‚è≥ –ó–∞–≥—Ä—É–∂–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è <b><code>{text.upper()}</code></b> —á–µ—Ä–µ–∑ DEX Screener...",
                parse_mode="HTML"
            )

            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ
            response = await get_coin_prices(text.upper())

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            await update.message.reply_text(
                text=response,
                parse_mode="HTML",
                disable_web_page_preview=True,
                reply_markup=get_main_keyboard()
            )
            return
        else:
            await update.message.reply_text(
                "‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –Ω–∞–∑–≤–∞–Ω–∏—è –º–æ–Ω–µ—Ç—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã –∏ —Ü–∏—Ñ—Ä—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä ETH –∏–ª–∏ BTC)",
                reply_markup=get_main_keyboard()
            )
            return

    await update.message.reply_text(
        "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é.",
        reply_markup=get_main_keyboard()
    )


async def handle_settings(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –º–µ–Ω—é –Ω–∞—Å—Ç—Ä–æ–µ–∫"""
    text = update.message.text

    if text == "üöÄÔ∏è –°–ø–æ—Ç –ê—Ä–±–∏—Ç—Ä–∞–∂":
        await update.message.reply_text(
            "üöÄÔ∏è <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ DEX –∞—Ä–±–∏—Ç—Ä–∞–∂–∞ v2.0</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è:",
            parse_mode="HTML",
            reply_markup=get_spot_settings_keyboard()
        )
        return SPOT_SETTINGS

    elif text == "üèõ DEX –ë–∏—Ä–∂–∏":
        await update.message.reply_text(
            "üèõ <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ DEX –±–∏—Ä–∂ v2.0</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ DEX –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è/–≤—ã–∫–ª—é—á–µ–Ω–∏—è:",
            parse_mode="HTML",
            reply_markup=get_dex_settings_keyboard()
        )
        return SETTINGS_MENU

    elif text == "üîÑ –°–±—Ä–æ—Å":
        global SETTINGS, LAST_DEX_SETTINGS
        SETTINGS = {
            "SPOT": DEFAULT_SPOT_SETTINGS.copy(),
            "DEX": DEX_EXCHANGES.copy()
        }
        save_settings(SETTINGS)
        LAST_DEX_SETTINGS = None
        await update.message.reply_text(
            "‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–±—Ä–æ—à–µ–Ω—ã –∫ –∑–Ω–∞—á–µ–Ω–∏—è–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é",
            reply_markup=get_settings_keyboard()
        )
        return SETTINGS_MENU

    elif text == "üîô –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é":
        await update.message.reply_text(
            "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:",
            reply_markup=get_main_keyboard()
        )
        return ConversationHandler.END

    await update.message.reply_text(
        "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é.",
        reply_markup=get_settings_keyboard()
    )
    return SETTINGS_MENU


async def handle_spot_settings(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ DEX –∞—Ä–±–∏—Ç—Ä–∞–∂–∞"""
    text = update.message.text

    if text == "üîô –ù–∞–∑–∞–¥ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏":
        await update.message.reply_text(
            "‚öôÔ∏è <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ DEX –±–æ—Ç–∞ v2.0</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:",
            parse_mode="HTML",
            reply_markup=get_settings_keyboard()
        )
        return SETTINGS_MENU

    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
    if text.startswith("–ü–æ—Ä–æ–≥:"):
        context.user_data['setting'] = ('SPOT', 'THRESHOLD_PERCENT')
        await update.message.reply_text(
            f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø–æ—Ä–æ–≥–∞ –∞—Ä–±–∏—Ç—Ä–∞–∂–∞ (—Ç–µ–∫—É—â–µ–µ: {SETTINGS['SPOT']['THRESHOLD_PERCENT']}%):"
        )
        return SETTING_VALUE

    elif text.startswith("–ú–∞–∫—Å. –ø–æ—Ä–æ–≥:"):
        context.user_data['setting'] = ('SPOT', 'MAX_THRESHOLD_PERCENT')
        await update.message.reply_text(
            f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –ø–æ—Ä–æ–≥–∞ (—Ç–µ–∫—É—â–µ–µ: {SETTINGS['SPOT']['MAX_THRESHOLD_PERCENT']}%):"
        )
        return SETTING_VALUE

    elif text.startswith("–ò–Ω—Ç–µ—Ä–≤–∞–ª:"):
        context.user_data['setting'] = ('SPOT', 'CHECK_INTERVAL')
        await update.message.reply_text(
            f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ (—Ç–µ–∫—É—â–µ–µ: {SETTINGS['SPOT']['CHECK_INTERVAL']} —Å–µ–∫):"
        )
        return SETTING_VALUE

    elif text.startswith("–û–±—ä–µ–º:"):
        context.user_data['setting'] = ('SPOT', 'MIN_VOLUME_USD')
        await update.message.reply_text(
            f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –æ–±—ä–µ–º–∞ (—Ç–µ–∫—É—â–µ–µ: ${SETTINGS['SPOT']['MIN_VOLUME_USD']}):"
        )
        return SETTING_VALUE

    elif text.startswith("–ú–∏–Ω. —Å—É–º–º–∞:"):
        context.user_data['setting'] = ('SPOT', 'MIN_ENTRY_AMOUNT_USDT')
        await update.message.reply_text(
            f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π —Å—É–º–º—ã –≤—Ö–æ–¥–∞ (—Ç–µ–∫—É—â–µ–µ: ${SETTINGS['SPOT']['MIN_ENTRY_AMOUNT_USDT']}):"
        )
        return SETTING_VALUE

    elif text.startswith("–ú–∞–∫—Å. —Å—É–º–º–∞:"):
        context.user_data['setting'] = ('SPOT', 'MAX_ENTRY_AMOUNT_USDT')
        await update.message.reply_text(
            f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Å—É–º–º—ã –≤—Ö–æ–¥–∞ (—Ç–µ–∫—É—â–µ–µ: ${SETTINGS['SPOT']['MAX_ENTRY_AMOUNT_USDT']}):"
        )
        return SETTING_VALUE

    elif text.startswith("–ü—Ä–∏–±—ã–ª—å:"):
        context.user_data['setting'] = ('SPOT', 'MIN_NET_PROFIT_USD')
        await update.message.reply_text(
            f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –ø—Ä–∏–±—ã–ª–∏ (—Ç–µ–∫—É—â–µ–µ: ${SETTINGS['SPOT']['MIN_NET_PROFIT_USD']}):"
        )
        return SETTING_VALUE

    elif text.startswith("–°—Ö–æ–¥–∏–º–æ—Å—Ç—å:"):
        context.user_data['setting'] = ('SPOT', 'PRICE_CONVERGENCE_THRESHOLD')
        await update.message.reply_text(
            f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø–æ—Ä–æ–≥–∞ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏ —Ü–µ–Ω (—Ç–µ–∫—É—â–µ–µ: {SETTINGS['SPOT']['PRICE_CONVERGENCE_THRESHOLD']}%):"
        )
        return SETTING_VALUE

    elif text.startswith("–£–≤–µ–¥. —Å—Ä–∞–≤–Ω.:"):
        SETTINGS['SPOT']['PRICE_CONVERGENCE_ENABLED'] = not SETTINGS['SPOT']['PRICE_CONVERGENCE_ENABLED']
        save_settings(SETTINGS)
        status = "üîî –í–ö–õ" if SETTINGS['SPOT']['PRICE_CONVERGENCE_ENABLED'] else "üîï –í–´–ö–õ"
        await update.message.reply_text(
            f"‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Å—Ä–∞–≤–Ω–µ–Ω–∏–∏ —Ü–µ–Ω {status}",
            reply_markup=get_spot_settings_keyboard()
        )
        return SPOT_SETTINGS

    elif text.startswith("–°—Ç–∞—Ç—É—Å:"):
        SETTINGS['SPOT']['ENABLED'] = not SETTINGS['SPOT']['ENABLED']
        save_settings(SETTINGS)
        status = "–í–ö–õ" if SETTINGS['SPOT']['ENABLED'] else "–í–´–ö–õ"
        await update.message.reply_text(
            f"‚úÖ DEX –∞—Ä–±–∏—Ç—Ä–∞–∂ {status}",
            reply_markup=get_spot_settings_keyboard()
        )
        return SPOT_SETTINGS

    await update.message.reply_text(
        "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é.",
        reply_markup=get_spot_settings_keyboard()
    )
    return SPOT_SETTINGS


async def handle_dex_settings(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ DEX –±–∏—Ä–∂"""
    text = update.message.text

    if text == "üîô –ù–∞–∑–∞–¥ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏":
        await update.message.reply_text(
            "‚öôÔ∏è <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ DEX –±–æ—Ç–∞ v2.0</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:",
            parse_mode="HTML",
            reply_markup=get_settings_keyboard()
        )
        return SETTINGS_MENU

    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–∫–ª—é—á–µ–Ω–∏—è/–≤—ã–∫–ª—é—á–µ–Ω–∏—è DEX –±–∏—Ä–∂
    for dex in SETTINGS['DEX'].keys():
        if text.startswith(f"{dex}:"):
            SETTINGS['DEX'][dex]['ENABLED'] = not SETTINGS['DEX'][dex]['ENABLED']
            save_settings(SETTINGS)

            status = "‚úÖ –í–ö–õ" if SETTINGS['DEX'][dex]['ENABLED'] else "‚ùå –í–´–ö–õ"
            await update.message.reply_text(
                f"‚úÖ DEX {dex.upper()} {status}",
                reply_markup=get_dex_settings_keyboard()
            )
            return SETTINGS_MENU

    await update.message.reply_text(
        "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é.",
        reply_markup=get_dex_settings_keyboard()
    )
    return SETTINGS_MENU


async def handle_setting_value(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ –∑–Ω–∞—á–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"""
    text = update.message.text
    setting_info = context.user_data.get('setting')

    if not setting_info:
        await update.message.reply_text(
            "–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.",
            reply_markup=get_settings_keyboard()
        )
        return SETTINGS_MENU

    arb_type, setting_key = setting_info

    try:
        if setting_key in ['THRESHOLD_PERCENT', 'MAX_THRESHOLD_PERCENT', 'PRICE_CONVERGENCE_THRESHOLD']:
            value = float(text)
        elif setting_key in ['CHECK_INTERVAL']:
            value = int(text)
        elif setting_key in ['MIN_VOLUME_USD', 'MIN_ENTRY_AMOUNT_USDT', 'MAX_ENTRY_AMOUNT_USDT', 'MIN_NET_PROFIT_USD']:
            value = float(text)
        else:
            value = text

        SETTINGS[arb_type][setting_key] = value
        save_settings(SETTINGS)

        await update.message.reply_text(
            f"‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ {setting_key} –∏–∑–º–µ–Ω–µ–Ω–∞ –Ω–∞ {text}",
            reply_markup=get_spot_settings_keyboard()
        )

        return SPOT_SETTINGS

    except ValueError:
        await update.message.reply_text(
            "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ.",
            reply_markup=get_spot_settings_keyboard()
        )
        return SETTING_VALUE


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û—Ç–º–µ–Ω–∞ –¥–∏–∞–ª–æ–≥–∞"""
    await update.message.reply_text(
        "–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.",
        reply_markup=get_main_keyboard()
    )
    return ConversationHandler.END


async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫"""
    logger.error(f"–û—à–∏–±–∫–∞: {context.error}", exc_info=context.error)

    if update and update.effective_message:
        await update.effective_message.reply_text(
            "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
            reply_markup=get_main_keyboard()
        )


def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞"""
    application = Application.builder().token(TELEGRAM_TOKEN).build()

    # Conversation handler –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–∫
    conv_handler = ConversationHandler(
        entry_points=[
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message)
        ],
        states={
            SETTINGS_MENU: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_settings)
            ],
            SPOT_SETTINGS: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_spot_settings)
            ],
            SETTING_VALUE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_setting_value)
            ]
        },
        fallbacks=[CommandHandler("cancel", cancel)]
    )

    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
    application.add_handler(CommandHandler("start", start))
    application.add_handler(conv_handler)
    application.add_error_handler(error_handler)

    # –ó–∞–ø—É—Å–∫–∞–µ–º DEX –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—É—é –∑–∞–¥–∞—á—É –≤ —Ñ–æ–Ω–µ
    loop = asyncio.get_event_loop()
    loop.create_task(check_spot_arbitrage())

    logger.info("DEX –∞—Ä–±–∏—Ç—Ä–∞–∂ –±–æ—Ç v2.0 –∑–∞–ø—É—â–µ–Ω —Å DEX Screener API")

    # –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
    application.run_polling()


if __name__ == '__main__':
    main()
